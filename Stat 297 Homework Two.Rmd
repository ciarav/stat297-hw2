---
title: "STAT 297 Homework 2"
author: "Austin Gongora, Ian Willick, Ciara Virgo, Mark Hancharik"
date: "October 13, 2017"

output: 
  html_document:
    theme: paper    
    highlight: tango 
    toc: true
    toc_depth: 3
    toc_float: true

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Fizz Buzz (showing the last 15 of 1000)



```{r,  echo=FALSE}

# we don't need this 'u' variable, it just makes it easier to change the length -MH
u = 10^4

results <- vector(mode = "character", length = u)

 for(i in 1:u) {
  x = i
  
    if (x %% (3 * 5) == 0){    # shortened from this:  if (x %% 3 == 0 & x %% 5 == 0){
      results[i] <- "fizz buzz"
      }else if (x %% 3 == 0){
      results[i] <- "fizz"
      }else if (x %% 5 == 0){
      results[i]  <- "buzz"
      }else{
      results[i]  <- i
    }

 }



tail(results, n=15) 

```

## Map

I haven't found the template that was used in the homework yet, it gives you just the outline of the states
<<<<<<< Updated upstream
```{r,  echo=FALSE}


library(ggmap)

bigten_location <- c("Columbus, Ohio", "East Lansing, Michigan", "State College, Pennslyvania","Ann Arbor, Michigan", "Lincoln, Nebraska","Madison, Wisconsin", "Iowa City, Iowa","Bloomington, Indiana", "Urbana, Illinois","College Park, Maryland", "Minneapolis, Minnesota","Chicago, Illinois", "West Lafayette, Indiana","Rutgers, New Jersey")
bigten_coord <- geocode(bigten_location)

# it seems like when I run this, random coordinates are "NA"
bigten_coord

#map <- get_map(location = 'Ohio', zoom = 6)
#ggmap(map) + geom_point(data = uni_coord, 
             aes(lon, lat, col = big10, size = GS)) + 
             scale_size(name= "Number of wins") + 
             xlab("Longitude") + ylab("Latitude")

map <- get_map(location = 'Michigan', zoom = 4)
ggmap(map) + geom_point(data = uni_coord, 
             aes(lon, lat, col = big10, size = GS)) + 
             scale_size(name= "Number of wins") + 
             xlab("Longitude") + ylab("Latitude")
             
map <- get_map(location = 'Pennsylvania', zoom = 8)
ggmap(map) + geom_point(data = uni_coord, 
             aes(lon, lat, col = big10, size = GS)) + 
             scale_size(name= "Number of wins") + 
             xlab("Longitude") + ylab("Latitude")
             
library(mapproj)
map <- get_map(location = 'Michigan', zoom = 3)
ggmap(map) + geom_point(data = uni_coord, 
             aes(lon, lat, col = big10, size = GS)) + 
             scale_size(name="Number of wins") + 
             xlab("Longitude") + ylab("Latitude")

map <- get_map(location = 'Nebraska', zoom = 4)
ggmap(map) + geom_point(data = uni_coord, 
             aes(lon, lat, col = big10, size = GS)) + 
             scale_size(name= "Number of wins") + 
             xlab("Longitude") + ylab("Latitude")

map <- get_map(location = 'Wisconsin', zoom = 4)
ggmap(map) + geom_point(data = uni_coord, 
             aes(lon, lat, col = big10, size = GS)) + 
             scale_size(name= "Number of wins") + 
             xlab("Longitude") + ylab("Latitude")
             
library(mapproj)
map <- get_map(location = 'Iowa', zoom = 2)
ggmap(map) + geom_point(data = uni_coord, 
             aes(lon, lat, col = big10, size = GS)) + 
             scale_size(name="Number of wins") + 
             xlab("Longitude") + ylab("Latitude")
                        
library(mapproj)
map <- get_map(location = 'Indiana', zoom = 4)
ggmap(map) + geom_point(data = uni_coord, 
             aes(lon, lat, col = big10, size = GS)) + 
             scale_size(name="Number of wins") + 
             xlab("Longitude") + ylab("Latitude")
             
library(mapproj)
map <- get_map(location = 'Illinois', zoom = 3)
ggmap(map) + geom_point(data = uni_coord, 
             aes(lon, lat, col = big10, size = GS)) + 
             scale_size(name="Number of wins") + 
             xlab("Longitude") + ylab("Latitude")
             
library(mapproj)
map <- get_map(location = 'Maryland', zoom = 2)
ggmap(map) + geom_point(data = uni_coord, 
             aes(lon, lat, col = big10, size = GS)) + 
             scale_size(name="Number of wins") + 
             xlab("Longitude") + ylab("Latitude")
                
library(mapproj)
map <- get_map(location = 'Minnesota', zoom = 3)
ggmap(map) + geom_point(data = uni_coord, 
             aes(lon, lat, col = big10, size = GS)) + 
             scale_size(name="Number of wins") + 
             xlab("Longitude") + ylab("Latitude")
             
library(mapproj)
map <- get_map(location = 'Illinois', zoom = 3)
ggmap(map) + geom_point(data = uni_coord, 
             aes(lon, lat, col = big10, size = GS)) + 
             scale_size(name="Number of wins") + 
             xlab("Longitude") + ylab("Latitude")
             
library(mapproj)
map <- get_map(location = 'Indiana', zoom = 4)
ggmap(map) + geom_point(data = uni_coord, 
             aes(lon, lat, col = big10, size = GS)) + 
             scale_size(name="Number of wins") + 
             xlab("Longitude") + ylab("Latitude")
             
library(mapproj)
map <- get_map(location = 'New Jersey', zoom = 3)
ggmap(map) + geom_point(data = uni_coord, 
             aes(lon, lat, col = big10, size = GS)) + 
             scale_size(name="Number of wins") + 
             xlab("Longitude") + ylab("Latitude")


```
=======
>>>>>>> Stashed changes


This is from the homework, it gives us the win percentages and conference sections as well as the coordinates:



library(maps)
library(ggmap)
library(rvest)

a# Define webpage
big10 = read_html("http://www.bigten.org/library/stats/fb-confsked.html#standings")

a# Get uni names
big10 %>% 
    html_nodes(".b1gfbstats:nth-child(9) td:nth-child(1) , .b1gfbstats:nth-child(6) td:nth-child(1)") %>% 
    html_text() -> uni_name
uni_name = paste(uni_name,"University")

a# Find uni locations
uni_coord = data.frame(geocode(uni_name))

a# Get win rate
big10 %>% 
    html_nodes("td:nth-child(7)") %>%
    html_text() -> uni_wp
uni_coord$wp = 100*as.numeric(uni_wp[1:length(uni_name)])

a# Get division
uni_coord$conf = rep(c("East Division","West Division"), each = length(uni_name)/2)


a# it seems like when I run this, random coordinates are "NA"
uni_coord








## 3D-random walks

a = (1/6), B = 10^4, seed = 1982:
```{r,  echo=FALSE}



timesToRun = 1

# set the size of the walk
walkSize = 10^4

#create a location vector to store x,y,z values
location <- c("X Axis" = 0, "Y Axis" = 0, "Z Axis" = 0)

# create a matrix to store the location points
path <- matrix(NaN, walkSize, 3, byrow=TRUE)

#add the start point to the path
path[1,] <- c(location[1],location[2],location[3])




# start a loop to run it n times and get n random endpoints
# create a matrix to store the location endpoints
endpoints <- matrix(NaN, timesToRun, 3, byrow=TRUE)
 for(j in 1:timesToRun) {

   
   
# here we generate the random walk numbers for the six possible moves
B <- walkSize
set.seed(1982)
Ut <- runif(B)

#boxOfNumbers <- c(sample(1:6, walkSize, replace=TRUE)) # replace = TRUE to allow for repeat numbers  
# instead of generating ints, generate a double between 0-1 and convert to an int
boxOfNumbers <- vector(mode = "integer", length = walkSize)  


for(i in 1:walkSize){
  currentNumber <- Ut[i] #runif(1)
  if(currentNumber <= (1/6)){
    boxOfNumbers[i] <- 1
  }else if(currentNumber <= (2/6)){
    boxOfNumbers[i] <- 2
  }else if(currentNumber <= (3/6)){
    boxOfNumbers[i] <- 3
  }else if(currentNumber <= (4/6)){
    boxOfNumbers[i] <- 4
  }else if(currentNumber <= (5/6)){
    boxOfNumbers[i] <- 5
  }else{
    boxOfNumbers[i] <- 6
  }

}   
   
# and we convert those moves to xyz coordinates here:
 for(i in 1:walkSize) { # set this from 2 instead of one because 1 is our starting point
   
   switch(boxOfNumbers[i],
       location[1] <- location[1] + 1,
       location[1] <- location[1] - 1,
       location[2] <- location[2] + 1,
       location[2] <- location[2] - 1,
       location[3] <- location[3] + 1,
       location[3] <- location[3] - 1
     
   )
    path[i,] <- c(location[1],location[2],location[3])
 } #end for(i in 1:walkSize) 

# add the endpoint  
 endpoints[j,] <- c(location[1],location[2],location[3])
 #reset origin to [0,0,0]
 location[1] <- 0
 location[2] <- 0
 location[3] <- 0
} # end ten loop

# https://stackoverflow.com/questions/77434/how-to-access-the-last-value-in-a-vector#83222
tail(path, n=1)

# print some things out to see if it's working...
#endpoints

#head(Ut)
#print("0.7533571 0.6056869 0.4977858 0.6473441 0.2183902 0.4594699 <-- expected value")
#boxOfNumbers
#path


 

```


a = (.99)(1/6), B = 10^5, seed = 2000:
```{r, echo=FALSE}


timesToRun = 1

# set the size of the walk
walkSize = 10^5

#create a location vector to store x,y,z values
location <- c("X Axis" = 0, "Y Axis" = 0, "Z Axis" = 0)

# create a matrix to store the location points
path <- matrix(NaN, walkSize, 3, byrow=TRUE)

#add the start point to the path
path[1,] <- c(location[1],location[2],location[3])




# start a loop to run it n times and get n random endpoints
# create a matrix to store the location endpoints
endpoints <- matrix(NaN, timesToRun, 3, byrow=TRUE)
 for(j in 1:timesToRun) {

   
   
# here we generate the random walk numbers for the six possible moves
B <- walkSize
set.seed(2000)
Ut <- runif(B)

#boxOfNumbers <- c(sample(1:6, walkSize, replace=TRUE)) # replace = TRUE to allow for repeat numbers  
   # instead of generating ints, generate a double between 0-1 and convert to an int
boxOfNumbers <- vector(mode = "integer", length = walkSize)  


for(i in 1:walkSize){
  currentNumber <- Ut[i] #runif(1)
  if(currentNumber <= ((1/6)*.99)){
    boxOfNumbers[i] <- 1
  }else if(currentNumber <= ((2/6)*.99)){
    boxOfNumbers[i] <- 2
  }else if(currentNumber <= ((3/6)*.99)){
    boxOfNumbers[i] <- 3
  }else if(currentNumber <= ((4/6)*.99)){
    boxOfNumbers[i] <- 4
  }else if(currentNumber <= ((5/6)*.99)){
    boxOfNumbers[i] <- 5
  }else{
    boxOfNumbers[i] <- 6
  }

}  
   
# and we convert those moves to xyz coordinates here:
 for(i in 1:walkSize) { # set this from 2 instead of one because 1 is our starting point
   
   switch(boxOfNumbers[i],
       location[1] <- location[1] + 1,
       location[1] <- location[1] - 1,
       location[2] <- location[2] + 1,
       location[2] <- location[2] - 1,
       location[3] <- location[3] + 1,
       location[3] <- location[3] - 1
     
   )
    path[i,] <- c(location[1],location[2],location[3])
 } #end for(i in 1:walkSize) 

# add the endpoint  
 endpoints[j,] <- c(location[1],location[2],location[3])
 #reset origin to [0,0,0]
 location[1] <- 0
 location[2] <- 0
 location[3] <- 0
} # end ten loop
#endpoints
# https://stackoverflow.com/questions/77434/how-to-access-the-last-value-in-a-vector#83222
tail(path, n=1)
# print out the expected value
#print("[142, -133, -899]")
```


## Construct a portfolio

```{r, echo=FALSE}
sp500names <- c( "ABT","ABBV","ACN","ATVI","AYI","ADBE","AMD","AAP",
 "AES","AET","AMG","AFL","A","APD","AKAM","ALK",
 "ALB","ARE","ALXN","ALGN","ALLE","AGN","ADS","LNT",
 "ALL","GOOGL", "GOOG","MO", "AMZN","AEE","AAL","AEP",
 "AXP","AIG","AMT","AWK","AMP","ABC","AME","AMGN", 
 "APH","APC","ADI","ANDV","ANSS","ANTM","AON","AOS",
 "APA","AIV","AAPL","AMAT","ADM","ARNC","AJG","AIZ",
 "T","ADSK","ADP","AZO","AVB","AVY","BHGE","BLL",
 "BAC","BK", "BCR","BAX","BBT","BDX","BRK-B", "BBY",
 "BIIB","BLK","HRB","BA", "BWA","BXP","BSX","BHF",
 "BMY","AVGO","BF-B","CHRW","CA", "COG","CDNS","CPB",
 "COF","CAH","CBOE","KMX","CCL","CAT","CBG","CBS",
"CELG","CNC","CNP","CTL","CERN","CF", "SCHW","CHTR", 
 "CHK","CVX","CMG","CB", "CHD","CI", "XEC","CINF", 
 "CTAS","CSCO","C","CFG","CTXS","CLX","CME","CMS",
 "COH","KO", "CTSH","CL", "CMCSA", "CMA","CAG","CXO",
 "COP","ED", "STZ","COO","GLW","COST","COTY","CCI",
"CSRA","CSX","CMI","CVS","DHI","DHR","DRI","DVA",
 "DE", "DLPH","DAL","XRAY","DVN","DLR","DFS","DISCA",
 "DISCK", "DISH","DG", "DLTR","D","DOV","DWDP","DPS",
 "DTE","DRE","DUK","DXC","ETFC","EMN","ETN","EBAY", 
 "ECL","EIX","EW", "EA", "EMR","ETR","EVHC","EOG",
 "EQT","EFX","EQIX","EQR","ESS","EL", "ES", "RE",
 "EXC","EXPE","EXPD","ESRX","EXR","XOM","FFIV","FB",
 "FAST","FRT","FDX","FIS","FITB","FE", "FISV","FLIR", 
 "FLS","FLR","FMC","FL", "F","FTV","FBHS","BEN",
 "FCX","GPS","GRMN","IT", "GD", "GE", "GGP","GIS",
 "GM", "GPC","GILD","GPN","GS", "GT", "GWW","HAL",
 "HBI","HOG","HRS","HIG","HAS","HCA","HCP","HP",
 "HSIC","HSY","HES","HPE","HLT","HOLX","HD", "HON",
 "HRL","HST","HPQ","HUM","HBAN","IDXX","INFO","ITW",
 "ILMN","IR", "INTC","ICE","IBM","INCY","IP", "IPG",
"IFF","INTU","ISRG","IVZ","IRM","JEC","JBHT","SJM",
 "JNJ","JCI","JPM","JNPR","KSU","K","KEY","KMB",
"KIM","KMI","KLAC","KSS","KHC","KR", "LB", "LLL",
 "LH", "LRCX","LEG","LEN","LVLT","LUK","LLY","LNC",
"LKQ","LMT","L","LOW","LYB","MTB","MAC","M", 
"MRO","MPC","MAR","MMC","MLM","MAS","MA", "MAT",
 "MKC","MCD","MCK","MDT","MRK","MET","MTD","MGM",
 "KORS" , "MCHP" , "MU", "MSFT","MAA","MHK","TAP","MDLZ", 
 "MON","MNST","MCO","MS", "MOS","MSI","MYL","NDAQ", 
 "NOV","NAVI","NTAP","NFLX" , "NWL","NFX","NEM","NWSA",
 "NWS","NEE","NLSN" , "NKE","NI", "NBL","JWN","NSC",
 "NTRS","NOC","NRG","NUE","NVDA","ORLY","OXY","OMC",
"OKE","ORCL","PCAR","PKG","PH", "PDCO","PAYX","PYPL", 
"PNR","PBCT" , "PEP","PKI","PRGO","PFE","PCG","PM",
 "PSX","PNW","PXD","PNC","RL", "PPG","PPL","PX",
 "PCLN","PFG","PG", "PGR","PLD","PRU","PEG","PSA",
 "PHM","PVH","QRVO" , "PWR","QCOM","DGX","Q","RRC",
 "RJF","RTN","O","RHT","REG","REGN","RF", "RSG",
 "RMD","RHI","ROK","COL","ROP","ROST","RCL","CRM",
 "SBAC","SCG","SLB","SNI","STX","SEE","SRE","SHW",
 "SIG","SPG","SWKS","SLG","SNA","SO", "LUV","SPGI", 
 "SWK","SBUX","STT","SRCL","SYK","STI","SYMC","SYF",
 "SNPS","SYY","TROW","TGT","TEL","FTI","TXN","TXT",
 "TMO","TIF","TWX","TJX","TMK","TSS","TSCO","TDG",
 "TRV","TRIP","FOXA","FOX","TSN","UDR","ULTA","USB",
 "UA", "UAA","UNP","UAL","UNH","UPS","URI","UTX",
 "UHS","UNM","VFC","VLO","VAR","VTR","VRSN","VRSK", 
 "VZ", "VRTX","VIAB","V","VNO","VMC","WMT","WBA",
 "DIS","WM", "WAT","WEC","WFC","HCN","WDC","WU",
 "WRK","WY", "WHR","WMB","WLTW","WYN","WYNN","XEL",
 "XRX","XLNX","XL")

length(sp500names)
```

